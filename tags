!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BIN	Makefile	/^BIN := bin$/;"	m
CC	Makefile	/^CC := g++$/;"	m
CCFLAGS	Makefile	/^CCFLAGS := -I$(INC)$/;"	m
INC	Makefile	/^INC := include$/;"	m
Index2Protocol	include/protocol_system.h	/^		typedef map<int, protocol*> Index2Protocol;$/;"	t	class:protocol_system
LDFLAGS	Makefile	/^LDFLAGS := -lboost_system -lboost_thread -ljsoncpp -ltinyxml$/;"	m
Log	include/logger.h	6;"	d
Msg_Handler	include/tcp_connector.h	/^		typedef boost::function<void(string&)> Msg_Handler;$/;"	t	class:tcp_connector
Name2Protocol	include/protocol_system.h	/^		typedef map<string, protocol*> Name2Protocol;$/;"	t	class:protocol_system
OBJ	Makefile	/^OBJ := obj$/;"	m
SRC	Makefile	/^SRC := src$/;"	m
TARGET	Makefile	/^TARGET := test$/;"	m
Tcp_Pointer	include/tcp_connector.h	/^		typedef boost::shared_ptr<tcp_connector> Tcp_Pointer;$/;"	t	class:tcp_connector
_CLIENT_H	include/client.h	2;"	d
_CODE_BREAKER_H	include/code_breaker.h	2;"	d
_CONFIG_H	include/config.h	2;"	d
_LOGGER_H	include/logger.h	2;"	d
_MEM_BLOCK_H	include/mem_block.h	2;"	d
_MESSAGE_HANDLER_H	include/message_handler.h	2;"	d
_MSG_JSON_H	include/msg_json.h	2;"	d
_NONCOPYABLE_H	include/noncopyable.h	2;"	d
_PROTOCOL_SYSTEM_H	include/protocol_system.h	2;"	d
_SINGLETON_H	include/singleton.h	2;"	d
_TCP_CONNECTOR_H	include/tcp_connector.h	2;"	d
_TOOLS_H	include/tools.h	2;"	d
_XML_PARSER_H	include/xml_parser.h	2;"	d
_buff_size	include/tcp_connector.h	/^		unsigned int _buff_size;$/;"	m	class:tcp_connector
_connector	include/client.h	/^		tcp_connector::Tcp_Pointer _connector;$/;"	m	class:client
_default_buff_size	include/tcp_connector.h	/^			_default_buff_size = 1024$/;"	e	enum:tcp_connector::__anon3
_get_all_node	src/xml_parser.cpp	/^void xml_parser::_get_all_node(TiXmlElement* pRoot, const string& strNodeName, vector<TiXmlElement*>& pNodeVec)$/;"	f	class:xml_parser
_get_all_node_by_condition	src/xml_parser.cpp	/^void xml_parser::_get_all_node_by_condition(TiXmlElement* pRoot, const string& strNodeName, map<string, string>& condition, vector<TiXmlElement*>& pNodeVec)$/;"	f	class:xml_parser
_get_first_node	src/xml_parser.cpp	/^bool xml_parser::_get_first_node(TiXmlElement* pRoot, const string& strNodeName, TiXmlElement*& pNode)$/;"	f	class:xml_parser
_get_first_node_by_condition	src/xml_parser.cpp	/^bool xml_parser::_get_first_node_by_condition(TiXmlElement* pRoot, const string& strNodeName, map<string, string>& condition, TiXmlElement*& pNode)$/;"	f	class:xml_parser
_handler	include/tcp_connector.h	/^		Msg_Handler _handler;$/;"	m	class:tcp_connector
_header_size	include/msg_json.h	/^			_header_size = 12$/;"	e	enum:msg_json::__anon2
_id	include/config.h	/^		string _id;$/;"	m	class:config
_index	include/protocol_system.h	/^		int _index;$/;"	m	struct:protocol
_index_to_protocol_map	include/protocol_system.h	/^		Index2Protocol _index_to_protocol_map;$/;"	m	class:protocol_system
_io_service	include/tcp_connector.h	/^		boost::asio::io_service& _io_service;$/;"	m	class:tcp_connector
_ip	include/config.h	/^		string _ip;$/;"	m	class:config
_json_str_utf8	include/msg_json.h	/^		const char* _json_str_utf8;$/;"	m	struct:msg_json
_msg	include/code_breaker.h	/^			string& _msg;$/;"	m	class:code_breaker::decode_msg_json_helper
_mutex	include/singleton.h	/^	static pthread_mutex_t _mutex;$/;"	m	class:singleton
_mutex	include/singleton.h	/^pthread_mutex_t singleton<T>::_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:singleton
_name	include/protocol_system.h	/^		string _name;$/;"	m	struct:protocol
_name	include/xml_parser.h	/^		string _name;$/;"	m	class:xml_parser
_name_to_protocol_map	include/protocol_system.h	/^		Name2Protocol _name_to_protocol_map;$/;"	m	class:protocol_system
_net_id	include/client.h	/^		int _net_id;$/;"	m	class:client
_net_id	include/msg_json.h	/^		int _net_id;$/;"	m	struct:msg_json
_offset	include/code_breaker.h	/^			int _offset;$/;"	m	class:code_breaker::decode_msg_json_helper
_pDoc	include/xml_parser.h	/^		mutable TiXmlDocument* _pDoc;$/;"	m	class:xml_parser
_pInstance	include/singleton.h	/^    static T* _pInstance;$/;"	m	class:singleton
_pInstance	include/singleton.h	/^T* singleton<T>::_pInstance = NULL;$/;"	m	class:singleton
_passwd	include/config.h	/^		string _passwd;$/;"	m	class:config
_player_id	include/client.h	/^		int _player_id;$/;"	m	class:client
_player_id	include/msg_json.h	/^		int _player_id;$/;"	m	struct:msg_json
_port	include/config.h	/^		string _port;$/;"	m	class:config
_pstr	include/mem_block.h	/^		char* _pstr;$/;"	m	class:mem_block
_read_buff	include/tcp_connector.h	/^		char* _read_buff;$/;"	m	class:tcp_connector
_sample	include/protocol_system.h	/^		string _sample;$/;"	m	struct:protocol
_sample_file	include/config.h	/^	    string _sample_file;$/;"	m	class:config
_size	include/mem_block.h	/^		int _size;$/;"	m	class:mem_block
_socket	include/tcp_connector.h	/^		tcp::socket _socket;$/;"	m	class:tcp_connector
_time_checker	include/client.h	/^		map<int, time_t> _time_checker;$/;"	m	class:client
_total_len	include/msg_json.h	/^		short _total_len;$/;"	m	struct:msg_json
_type	include/msg_json.h	/^		short _type;$/;"	m	struct:msg_json
_write_queue	include/tcp_connector.h	/^		msg_queue _write_queue;$/;"	m	class:tcp_connector
_xml_parser	include/protocol_system.h	/^		xml_parser _xml_parser;$/;"	m	class:protocol_system
account_req_begin	include/client.h	/^			account_req_begin = 10,$/;"	e	enum:client::__anon1
acount_resp_begin	include/client.h	/^			acount_resp_begin = 110,$/;"	e	enum:client::__anon1
check_condition	src/xml_parser.cpp	/^bool xml_parser::check_condition(TiXmlElement* pNode, map<string, string>& condition)$/;"	f	class:xml_parser
check_pDoc	src/xml_parser.cpp	/^bool xml_parser::check_pDoc() const$/;"	f	class:xml_parser
client	include/client.h	/^class client : public noncopyable$/;"	c
client	src/client.cpp	/^client::client(boost::asio::io_service& io_service, const string& ip, const string& port)$/;"	f	class:client
close	src/tcp_connector.cpp	/^void tcp_connector::close()$/;"	f	class:tcp_connector
code_breaker	include/code_breaker.h	/^namespace code_breaker$/;"	n
config	include/config.h	/^class config : public singleton<config>$/;"	c
config	src/config.cpp	/^config::config()$/;"	f	class:config
connect	src/tcp_connector.cpp	/^void tcp_connector::connect(const string& ip, const string& port)$/;"	f	class:tcp_connector
convert_binary	include/tools.h	/^	inline static void convert_binary(char* binary, int len)$/;"	f	namespace:tools
create	src/tcp_connector.cpp	/^tcp_connector::Tcp_Pointer tcp_connector::create(boost::asio::io_service& io_service, unsigned int buff_size)$/;"	f	class:tcp_connector
decode_msg_json	include/code_breaker.h	/^			bool decode_msg_json(msg_json& result)$/;"	f	class:code_breaker::decode_msg_json_helper
decode_msg_json_helper	include/code_breaker.h	/^			decode_msg_json_helper(string& msg)$/;"	f	class:code_breaker::decode_msg_json_helper
decode_msg_json_helper	include/code_breaker.h	/^	class decode_msg_json_helper$/;"	c	namespace:code_breaker
del_first_node	src/xml_parser.cpp	/^bool xml_parser::del_first_node(const string& strNodeName)$/;"	f	class:xml_parser
deps	Makefile	/^deps = $(objs:%.o=%.d)$/;"	m
destory_instance	include/singleton.h	/^    void destory_instance()$/;"	f	class:singleton
do_close	src/tcp_connector.cpp	/^void tcp_connector::do_close()$/;"	f	class:tcp_connector
do_write	src/tcp_connector.cpp	/^void tcp_connector::do_write(const string& str)$/;"	f	class:tcp_connector
encode_msg_json	include/code_breaker.h	/^	inline void encode_msg_json(msg_json& msg, string& result)$/;"	f	namespace:code_breaker
get_all_node	src/xml_parser.cpp	/^bool xml_parser::get_all_node(const string& strNodeName, vector<TiXmlElement*>& pNodeVec)$/;"	f	class:xml_parser
get_all_node_by_condition	src/xml_parser.cpp	/^bool xml_parser::get_all_node_by_condition(const string& strNodeName, map<string, string>& condition, vector<TiXmlElement*>& pNodeVec)$/;"	f	class:xml_parser
get_declaration	src/xml_parser.cpp	/^bool xml_parser::get_declaration(string& strVersion, string& strStandalone, string& strEncoding)$/;"	f	class:xml_parser
get_first_node	src/xml_parser.cpp	/^bool xml_parser::get_first_node(const string& strNodeName, TiXmlElement*& pNode)$/;"	f	class:xml_parser
get_first_node_by_condition	src/xml_parser.cpp	/^bool xml_parser::get_first_node_by_condition(const string& strNodeName, map<string, string>& condition, TiXmlElement*& pNode)$/;"	f	class:xml_parser
get_id	src/config.cpp	/^string config::get_id()$/;"	f	class:config
get_ip	src/config.cpp	/^string config::get_ip()$/;"	f	class:config
get_passwd	src/config.cpp	/^string config::get_passwd()$/;"	f	class:config
get_port	src/config.cpp	/^string config::get_port()$/;"	f	class:config
get_protocol_by_index	src/protocol_system.cpp	/^protocol* protocol_system::get_protocol_by_index(int index)$/;"	f	class:protocol_system
get_protocol_by_name	src/protocol_system.cpp	/^protocol* protocol_system::get_protocol_by_name(const string& name)$/;"	f	class:protocol_system
get_sample_file	src/config.cpp	/^string config::get_sample_file()$/;"	f	class:config
handle_connect	src/tcp_connector.cpp	/^void tcp_connector::handle_connect(const boost::system::error_code& error)$/;"	f	class:tcp_connector
handle_msg	src/client.cpp	/^void client::handle_msg(string& str)$/;"	f	class:client
handle_read	src/tcp_connector.cpp	/^void tcp_connector::handle_read(const boost::system::error_code& error, std::size_t bytes_transferred)$/;"	f	class:tcp_connector
handle_write	src/tcp_connector.cpp	/^void tcp_connector::handle_write(const boost::system::error_code& error)$/;"	f	class:tcp_connector
key	include/tools.h	/^	const static char key[30] = {	0xbc, 0x23, 0x9c, 0x76, 0x99,$/;"	m	namespace:tools
key_len	include/tools.h	/^	const static int key_len = 30;$/;"	m	namespace:tools
load_file	src/config.cpp	/^void config::load_file()$/;"	f	class:config
load_file	src/protocol_system.cpp	/^void protocol_system::load_file()$/;"	f	class:protocol_system
login	src/client.cpp	/^void client::login(const string& id, const string& passwd)$/;"	f	class:client
login_req	include/client.h	/^			login_req,$/;"	e	enum:client::__anon1
login_resp	include/client.h	/^			login_resp,$/;"	e	enum:client::__anon1
logout_req	include/client.h	/^			logout_req,$/;"	e	enum:client::__anon1
logout_resp	include/client.h	/^			logout_resp,$/;"	e	enum:client::__anon1
main	src/main.cpp	/^int main()$/;"	f
mem_block	include/mem_block.h	/^		mem_block(char* pstr, int size)$/;"	f	class:mem_block
mem_block	include/mem_block.h	/^		mem_block(const mem_block& rhs)$/;"	f	class:mem_block
mem_block	include/mem_block.h	/^class mem_block$/;"	c
message_handler	include/message_handler.h	/^class message_handler : public iMessage_handler$/;"	c
modify_all_attribute	src/xml_parser.cpp	/^bool xml_parser::modify_all_attribute(const string& strNodeName, map<string, string>& attrs)$/;"	f	class:xml_parser
modify_all_attribute_by_condition	src/xml_parser.cpp	/^bool xml_parser::modify_all_attribute_by_condition(const string& strNodeName, map<string, string>& condition, map<string, string>& attrs)$/;"	f	class:xml_parser
modify_first_attribute	src/xml_parser.cpp	/^bool xml_parser::modify_first_attribute(const string& strNodeName, map<string, string>& attrs)$/;"	f	class:xml_parser
modify_first_attribute_by_condition	src/xml_parser.cpp	/^bool xml_parser::modify_first_attribute_by_condition(const string& strNodeName, map<string, string>& condition, map<string, string>& attrs)$/;"	f	class:xml_parser
msg_json	include/msg_json.h	/^		msg_json()$/;"	f	struct:msg_json
msg_json	include/msg_json.h	/^struct msg_json$/;"	s
msg_queue	include/tcp_connector.h	/^		typedef std::deque<string> msg_queue;$/;"	t	class:tcp_connector
noncopyable	include/noncopyable.h	/^		noncopyable(){}$/;"	f	class:noncopyable
noncopyable	include/noncopyable.h	/^class noncopyable$/;"	c
objs	Makefile	/^objs = $(patsubst %.cpp, $(OBJ)\/%.o, $(notdir $(srcs)))$/;"	m
operator =	include/mem_block.h	/^		mem_block& operator=(const mem_block& rhs)$/;"	f	class:mem_block
pick_key	include/tools.h	/^	inline static char pick_key(int seek)$/;"	f	namespace:tools
post_read0	src/tcp_connector.cpp	/^void tcp_connector::post_read0()$/;"	f	class:tcp_connector
print	src/xml_parser.cpp	/^bool xml_parser::print() const$/;"	f	class:xml_parser
protocol	include/protocol_system.h	/^struct protocol$/;"	s
protocol_system	include/protocol_system.h	/^class protocol_system : public singleton<protocol_system>$/;"	c
protocol_system	src/protocol_system.cpp	/^protocol_system::protocol_system()$/;"	f	class:protocol_system
register_account	src/client.cpp	/^void client::register_account(const string& id, const string& passwd)$/;"	f	class:client
register_req	include/client.h	/^			register_req,$/;"	e	enum:client::__anon1
register_resp	include/client.h	/^			register_resp,$/;"	e	enum:client::__anon1
set_handler	src/tcp_connector.cpp	/^void tcp_connector::set_handler(Msg_Handler handler)$/;"	f	class:tcp_connector
shared	include/singleton.h	/^    static T* shared()$/;"	f	class:singleton
singleton	include/singleton.h	/^    singleton(){}$/;"	f	class:singleton
singleton	include/singleton.h	/^class singleton$/;"	c
srcs	Makefile	/^srcs = $(wildcard $(SRC)\/*.cpp)$/;"	m
tcp_connector	include/tcp_connector.h	/^class tcp_connector : public boost::enable_shared_from_this<tcp_connector>$/;"	c
tcp_connector	src/tcp_connector.cpp	/^tcp_connector::tcp_connector(boost::asio::io_service& io_service, unsigned int buff_size)$/;"	f	class:tcp_connector
tighten	include/tools.h	/^	inline string tighten(const string& str)$/;"	f	namespace:tools
tools	include/tools.h	/^namespace tools$/;"	n
update_sample	src/protocol_system.cpp	/^void protocol_system::update_sample(protocol* ptr, const string& sample)$/;"	f	class:protocol_system
write	src/client.cpp	/^void client::write(int type, Json::Value& data)$/;"	f	class:client
write	src/tcp_connector.cpp	/^void tcp_connector::write(const string& msg)$/;"	f	class:tcp_connector
xml_parser	include/xml_parser.h	/^		xml_parser(const string& name): _name(name), _pDoc(NULL){}$/;"	f	class:xml_parser
xml_parser	include/xml_parser.h	/^class xml_parser$/;"	c
~client	include/client.h	/^		~client(){}$/;"	f	class:client
~config	include/config.h	/^		virtual ~config(){}$/;"	f	class:config
~decode_msg_json_helper	include/code_breaker.h	/^			~decode_msg_json_helper(){}	$/;"	f	class:code_breaker::decode_msg_json_helper
~mem_block	include/mem_block.h	/^		~mem_block()$/;"	f	class:mem_block
~noncopyable	include/noncopyable.h	/^		~noncopyable(){}$/;"	f	class:noncopyable
~protocol_system	include/protocol_system.h	/^		virtual ~protocol_system(){}$/;"	f	class:protocol_system
~singleton	include/singleton.h	/^    virtual ~singleton(){}$/;"	f	class:singleton
~tcp_connector	src/tcp_connector.cpp	/^tcp_connector::~tcp_connector()$/;"	f	class:tcp_connector
~xml_parser	src/xml_parser.cpp	/^xml_parser::~xml_parser()$/;"	f	class:xml_parser
